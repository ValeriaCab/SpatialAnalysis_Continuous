//BURN-IN
//CABRERA VALERIA 
//Este codigo simula una poblacion en una dinamica poblacional de naciminetos y muerte
//sin mutaciones m2, ambiente homogeneo y sin slección. 

initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	
	if (!exists("RUNID")) defineConstant("RUNID", "default");	
	initializeTreeSeq(checkCoalescence=T);  
	  
	defineConstant("K", 5);	// carrying capacity
	defineConstant("SX", 0.3); // Escala de interacción
	defineConstant("N", 1000); // population size
	defineConstant("SD", 0.3); // Escala de dispersion 
	defineConstant("SM", 0.3); // Escala de apareamiento
	defineConstant("h2", 1.0);
	defineConstant("SW", 4);
	defineConstant("S_FEC", 2.0); // Coeficiente de Fecundidad
        defineConstant("LIFETIME", 4); //Average life span (4 generations)
        defineConstant("WIDTH", 25.0);
        defineConstant("HEIGHT", 25.0);
        defineConstant("regions", 3);
        defineGlobal("coalesc_gen", -1);
        defineConstant("FINISH", 250000); //Generaciones 
	
	// Set up constants that depend on externally defined parameters
	defineConstant("FECUN", 1/LIFETIME ); // defineConstant("FECUN", 1 / LIFETIME);
	defineConstant("RHO", FECUN  / ((1 + FECUN ) * K ));
		
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral mutation type
	initializeMutationType("m2", 0.5, "n", 0.0, 0.25); // QTLs affecting phenotype
	m2.convertToSubstitution = F; // Prevent mutation type from fixing
	m2.color = "red";
	initializeMutationRate(1.2e-8); // Number of new mutations = 2Nul = 2*3000*1e-8 * 1e8 = 
	initializeGenomicElementType("g1", c(m1, m2), c(0.0, 1.0)); // Genome element
	
	rec_ends = NULL;
	rec_rates = NULL;
	
	// Definimos 20 regiones de 25,000 pb
    for (index in 1:20) {
        start = (index - 1)*25000;
        end = start + 24999;

        // Crear el elemento genómico
        initializeGenomicElement(g1, start, end);

        // Baja recombinación dentro de la región
        rec_ends = c(rec_ends, end);
        rec_rates = c(rec_rates, 1e-8);

        // Alta recombinación entre regiones
        rec_ends = c(rec_ends, end + 1);
        rec_rates = c(rec_rates, 0.5);
    }

   initializeRecombinationRate(rec_rates, rec_ends);
   //catn("rec_rates: " + rec_rates);

	//Spatial interaction for local density
	initializeInteractionType(1, "xy", reciprocal= T, maxDistance= 3*SX);
	i1.setInteractionFunction("n", 1, SX);
	
	//Spatial interaction for mate choice
	initializeInteractionType(2, "xy", reciprocal= T, maxDistance= 3*SM);
	i2.setInteractionFunction("n", 1, SM);
}

mutationEffect(m2) { return 1.0;}

// 0 First events: ------------------------------------------------------------------

1 first() {
	// initialize population
	sim.addSubpop("p1", N);
	p1.setSpatialBounds(c(0, 0, WIDTH, HEIGHT));
	p1.individuals.setSpatialPosition(p1.pointUniform(p1.individualCount));

	// First map (Homogeneous) 
	defineConstant("mapValuesHomo", matrix(c(0, 0, 0, 0), ncol=2));	
	map = p1.defineSpatialMap("MAP", "xy", mapValuesHomo, interpolate=T, 
	      valueRange=c(0.0, 0.0), colors=c("yellow","yellow"));
        defineConstant("OPTIMUM", map);
	
	catn("\nPopulation size Gene 0: " + p1.individualCount + "\n");
}

first() {
   i2.evaluate(p1);
}

reproduction() {
	mate = i2.drawByStrength(individual, 1);
	if (mate.size())
		subpop.addCrossed(individual, mate, count=rpois(1, FECUN));
}

// 2 Early events: -------------------------------------------------------------------

early() {
	i1.evaluate(p1);
    
   // Disperse offspring
	offspring = p1.subsetIndividuals(maxAge=0);
   p1.deviatePositions(offspring, "reprising", INF, "n", SD);
   
   //Mapa Heterogeneo
   //if (sim.cycle == 1001) {
       //defineConstant("mapValuesHetero", matrix(c(0.7, 0.7, 0, 0), ncol=2));
       //p1.defineSpatialMap("mapHetero", "xy", mapValuesHetero, interpolate=T,valueRange=c(0.0, 1.0), colors=c("yellow", "red"));
   //}
       
   // Phenotype
   inds = sim.subpopulations.individuals;
   additive = inds.sumOfMutationsOfType(m2); 
   V_A = sd(additive)^2; // Additive genetic variance
   V_E = (V_A - h2 * V_A) / h2; // Environmental variance
   env = rnorm(size(inds), 0.0, sqrt(V_E)); // Environmental effects
   phenotypes = additive + env; // Total phenotype
   defineGlobal("phenotypes", phenotypes);
   
	// Get optimal fitness value from the current map
   location = inds.spatialPosition[rep(c(T, T), inds.size())];
   optimum = p1.spatialMapValue("MAP", location);
   
   // Fitness calculation 
   density = i1.localPopulationDensity(inds);
   inds.fitnessScaling = (exp(-(((phenotypes - optimum)^2) / ((2) * (SW^2))))) / (1 + RHO * density);
  
   // Update color of individuals based on the current map
   inds.color = OPTIMUM.mapColor(phenotypes);	
}

// Guardar árboles al final
late() {
    if (sim.treeSeqCoalesced() & coalesc_gen == -1 ) {
        catn(community.tick + ": COALESCED");
        coalesc_gen = 1;
        writeFile(RUNDIR + "/coales." + RUNID + ".txt",
                  community.tick + ": COALESCED\n", append=T);
        sim.treeSeqOutput(RUNDIR + "/trees." + RUNID + ".trees");
    }

    if (sim.cycle == FINISH & !sim.treeSeqCoalesced()) {
        catn(community.tick + ": NO COALESCED");

        writeFile(RUNDIR + "/coales." + RUNID + ".txt",
                  community.tick + ": NO COALESCED\n", append=T);

        sim.treeSeqOutput(RUNDIR + "/trees." + RUNID + ".trees");
    }
}

// Output all fixed mutations at end
FINISH late() {

   // Frequency vs Mutation Effect 
   qtls = sim.mutationsOfType(m2);
   f = sim.mutationFrequencies(NULL, qtls); //Frequency
   s = qtls.selectionCoeff; //Efect size
   indices = order(f, F); //vector de frecuencias de menor a mayor 
   
   for (i in indices) {
	line = paste(c(f[i], s[i]), sep="\t");
        writeFile(RUNDIR + "/Freq_vs_MutEffect." + RUNID + ".csv", line , append=T);

   }
   
   //Phenotype Value vs Region 
    inds = sim.subpopulations.individuals;
        
    div = WIDTH / regions;
    regions_vec = NULL;
	 
    for (index in 0:(regions-1)){
	start = index * div;
	end = (index + 1) * div;
	  
	if (index == 0) {
	    regions_vec = c(regions_vec, start);
        } 
        else{
	    regions_vec = c(regions_vec, start);
        }
	
        if (index < regions + 1 ) {
	    regions_vec = c(regions_vec, end - 0.001);
	    sample_region = inds[
                              (inds.x >= regions_vec[index * 2] ) &
	                      (inds.x < regions_vec[(index*2) + 1] )			      ];
	    catn("Región "+ (index + 1) + ": [" + regions_vec[index * 2] + ", " + regions_vec[(index*2) + 1] + "] → "
	          +  size(sample_region) + " individuos.");    
		 
		 
	    for (i in sample_region) {
		pheno_value = phenotypes[i.index];
		line = paste(i.index, pheno_value, index + 1, sep="\t");
	writeFile(RUNDIR + "/Phen_vs_Regions." + RUNID + ".csv", line, append=T);
	    } 
	}		
    }
    catn("\nPopulation size last generation: " + p1.individualCount + "\n");
    catn(regions_vec);
}
