// CLUSTER
// Part 1
// BURN-IN
// Author: Cabrera Valeria
// Description: This code simulates a population of 1,000 individuals. This leads to the 
// population coalescing at any time during 250,000 generations, often much earlier.
// In this scenario, stabilizing selection is present, the landscape is homogeneous, and the 
// population is dynamic, where each individual can disperse, mate, and produce offspring 
// during its lifetime. The genome length is 500,000 bp.
// Analyses: 1) Frequency of QTLs vs. mutation effect (in the total population)
//           2) Average phenotype value vs. region
//           3) Hudson's FST

 

initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	
	// Check if the population has already coalesced. 
	if (!exists("RUNID")) defineConstant("RUNID", "default");	
	initializeTreeSeq(checkCoalescence=T);  
	
	defineConstant("N", 1000); // population size
	defineConstant("K", 5);	   // local carrying capacity
	defineConstant("h2", 0.5); // hereditability
	defineConstant("SX", 0.3); // interaction scale
	defineConstant("SD", 0.3); // dispersion scale 
	defineConstant("SM", 0.3); //  Mating scale
	defineConstant("SW", 4);   // SE of the stabilizing selection function

        defineConstant("LIFETIME", 4); //Average life span (4 generations)
        defineConstant("WIDTH", 25.0); // Landscape size 
        defineConstant("HEIGHT", 25.0);
        defineConstant("regions", 3);  // Landscape regions
        defineGlobal("coalesc_gen", -1);  //Flag
        defineConstant("FINISH", 250000); //Total generations 
	
	// Set up constants that depend on externally defined parameters
	defineConstant("FECUN", 1/LIFETIME ); // defineConstant("FECUN", 1 / LIFETIME);
	defineConstant("RHO", FECUN  / ((1 + FECUN ) * K ));
		
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral mutation type
	initializeMutationType("m2", 0.5, "n", 0.0, 0.25); // QTLs affecting phenotype
	m2.convertToSubstitution = F; // Prevent mutation type from fixing
	m2.color = "red";
	initializeMutationRate(1.2e-8); // Number of new mutations = 2*N*MutRate*lenght 
	initializeGenomicElementType("g1", c(m1, m2), c(0.0, 1.0)); // Genome element
	
	// define 20 regions of 25,000 bp
	rec_ends = NULL;
	rec_rates = NULL;
	
    for (index in 1:20) {
        start = (index - 1)*25000;
        end = start + 24999;

        // Crear el elemento genómico
        initializeGenomicElement(g1, start, end);

        // Baja recombinación dentro de la región
        rec_ends = c(rec_ends, end);
        rec_rates = c(rec_rates, 1e-8);

        // Alta recombinación entre regiones
        rec_ends = c(rec_ends, end + 1);
        rec_rates = c(rec_rates, 0.5);
    }

   // Rate maps 
   initializeRecombinationRate(rec_rates, rec_ends);

	//Spatial interaction for local density
	initializeInteractionType(1, "xy", reciprocal= T, maxDistance= 3*SX);
	i1.setInteractionFunction("n", 1, SX);
	
	//Spatial interaction for mate choice
	initializeInteractionType(2, "xy", reciprocal= T, maxDistance= 3*SM);
	i2.setInteractionFunction("n", 1, SM);
}

mutationEffect(m2) { return 1.0;}

// 0 First events: ------------------------------------------------------------------

1 first() {
	// initialize population
	sim.addSubpop("p1", N);
	p1.setSpatialBounds(c(0, 0, WIDTH, HEIGHT));
	p1.individuals.setSpatialPosition(p1.pointUniform(p1.individualCount));

	// First map (Homogeneous) 
	defineConstant("mapValuesHomo", matrix(c(0, 0, 0, 0), ncol=2));	
	map = p1.defineSpatialMap("MAP", "xy", mapValuesHomo, interpolate=T, 
	      valueRange=c(0.0, 0.0), colors=c("yellow","yellow"));
        defineConstant("OPTIMUM", map);
	
        catn("\n---START SIMULATION---");
	catn("\nPopulation size Generation 0: " + p1.individualCount + "\n");
}

first() {
   i2.evaluate(p1); // Call to spatial interaction function 
}

reproduction() {
    //individual selection of a close mate(SM)
    mate = i2.drawByStrength(individual, 1);
    // If a person found a mate, then: 
    if (mate.size())
        //Offspring follow a Poisson distribution with mean FECUN:
	subpop.addCrossed(individual, mate, count=rpois(1, FECUN));
}

// 1 Early events: -------------------------------------------------------------------

early() {
  
   i1.evaluate(p1);
    
   // Disperse offspring
   offspring = p1.subsetIndividuals(maxAge=0);
   p1.deviatePositions(offspring, "reprising", INF, "n", SD);
       
   // Phenotype
   inds = sim.subpopulations.individuals;    // Individual vector
   additive = inds.sumOfMutationsOfType(m2); // Sum of Mutations with additive effect
   V_A = sd(additive)^2;                     // Additive genetic variance
   V_E = (V_A - h2 * V_A) / h2;              // Environmental variance
   env = rnorm(size(inds), 0.0, sqrt(V_E));  // Environmental effects
   phenotypes = additive + env;              // Total phenotype
   defineGlobal("phenotypes", phenotypes);
   
   // Get optimal fitness value from the current map
   location = inds.spatialPosition[rep(c(T, T), inds.size())];
   optimum = p1.spatialMapValue("MAP", location);
   
   // Fitness calculation 
   density = i1.localPopulationDensity(inds);
   inds.fitnessScaling = (exp(-(((phenotypes - optimum)^2) / ((2) * (SW^2))))) / (1 + RHO * density);
  
   // Update color of individuals based on the current map
   inds.color = OPTIMUM.mapColor(phenotypes);	
}

// Guardar árboles al final
late() {
    if (sim.treeSeqCoalesced()){
       if (coalesc_gen == -1 ) {
          coalesc_gen = community.tick;
          catn(coalesc_gen + ": COALESCED");
          writeFile(RUNDIR + "/coales." + RUNID + ".txt",
                   coalesc_gen + ": COALESCED\n", append=T);
          sim.treeSeqOutput(RUNDIR + "/trees." + RUNID + ".trees");
        }
    }
}

// 2 Final events ---------------------------------------------------------------------------
FINISH late() {

    if (!sim.treeSeqCoalesced()) {
        catn(community.tick + ": NO COALESCED");
        writeFile(RUNDIR + "/coales." + RUNID + ".txt",
                  community.tick + ": NO COALESCED\n", append=T);
        sim.treeSeqOutput(RUNDIR + "/trees." + RUNID + ".trees");
    }
    
   inds = sim.subpopulations.individuals;
   
   // Analysis 1
   // Frequency vs Mutation Effect  
   qtls = sim.mutationsOfType(m2);          // Population QTLs
   f = sim.mutationFrequencies(NULL, qtls); // Frequency
   s = qtls.selectionCoeff;                 // Efect size
   p = qtls.position;
   o = qtls.originTick;
   indices = order(f, F);                   // Frequency vector from lowest to highest  
   
   for (i in indices) {
	line = paste(c(f[i], s[i]), sep="\t");
        writeFile(RUNDIR + "/Freq_vs_MutEffect." + RUNID + ".csv", line , append=T);
        
        line_two = paste(c(p[i], s[i], f[i], o[i]), sep = "\t");
        writeFile(RUNDIR + "/Summary_QTLs." + RUNID + ".csv", line_two , append=T);
   }
   
   // Analysis 2 
   // Phenotype Value vs Region 
        
    div = WIDTH / regions; // Division of regions
    regions_vec = NULL;
    
    catn("\nREGIONES");
    freq_mean = c(); 
        
    // matrix: rows = QTLs, columns = regions
    freq_matrix = matrix(rep(0.0, size(qtls) * regions), size(qtls), regions);
    region_index = 0;
    num_ind_region = c(); 
    
    //Loop that traverses the regions of the map      
    for (index in 0:(regions-1)){
	start = index * div;
	end = (index + 1) * div - 0.001;
	  
	sample_region = inds[inds.x >= start & inds.x < end]; //muestra de ind en c/region
    	num_ind_region = c(num_ind_region, size(sample_region)); //Numero de individuos en c/region
    	
    	 catn("Region "+ (index + 1) + ": [" + start + "," + end + "] → "
    	       +  num_ind_region[index] + " individuals.");
    	 
    	 //Phenotype value for each individual by region 
	 for (i in sample_region) {
	     pheno_value = phenotypes[i.index];
	     line = paste(i.index, pheno_value, index + 1, sep="\t");
	     writeFile(RUNDIR + "/Phen_vs_Regions." + RUNID + ".csv", line, append=T);
	} 		
   
        // Frequency of each QTLS by region
        region_index = index + 1; 
        freqs = c();   // frequency vector
        for (mut in qtls) {
             count = 0;
             total_genomes = 2 * num_ind_region[index];  // diploides

            for (ind in sample_region) {
                if (ind.genome1.containsMutations(mut)){
                    count = count + 1;
                }
                if (ind.genome2.containsMutations(mut)){
                    count = count + 1;
                }
            }
            freqs = c(freqs, count / total_genomes);
         }

        // save this region as a column
        freq_matrix[, index] = freqs;
   }//(for) regions
  		  	
   catn("\nFinal population size: " + p1.individualCount);  
   catn("\nFrequency Matrix of QTLs x Region");
   print(freq_matrix); // QTL Matrix x Region 
    
   //FST Differences between allele frequencies in populations 
   catn("\nCOMPARISONS BETWEEN REGIONS");
    
    // QTL by QTL 
    // Matrices for sums between pairs of regions
    sum_num_matrix = matrix(rep(0.0, regions * regions), nrow=regions, ncol=regions);
    sum_den_matrix = matrix(rep(0.0, regions * regions), nrow=regions, ncol=regions);
	 
    for (qtl_index in 0:(size(qtls)-1)) {
        for (i in 0:(regions-2)) {
              for (j in (i+1):(regions-1)) {

                 pop_i = freq_matrix[qtl_index, i];
                 pop_j = freq_matrix[qtl_index, j];

                 size_i = num_ind_region[i];
                 size_j = num_ind_region[j];

                 // numerador Hudson
                 numerator = (pop_i - pop_j)^2
                        - (pop_i * (1 - pop_i))/(size_i - 1)
                        - (pop_j * (1 - pop_j))/(size_j - 1);

                 // denominador Hudson
                 denominator = pop_i * (1 - pop_j) + pop_j * (1 - pop_i);

                 catn("QTL " + qtl_index +
                     " Regions " + (i+1) + "-" + (j+1) +
                     " → Num=" + numerator +
                     " Den=" + denominator);
                     
                // Sum
                sum_num_matrix[i, j] = sum_num_matrix[i, j] + numerator;
                sum_den_matrix[i, j] = sum_den_matrix[i, j] + denominator;
           }          
       }
       catn("\n");
   }
   
   catn("\nEnd comparison");
   catn("\nSUM OF ALL REGION PAIRS\n");

   for (i in 0:(regions-2)) {
    	for (j in (i+1):(regions-1)) {
      	    catn("Regions " + (i+1) + "–" + (j+1));
       	    catn("  Sum of numerators = " + sum_num_matrix[i, j]);
            catn("  Sum of denominators = " + sum_den_matrix[i, j]);

            if (sum_den_matrix[i,j] > 0.0) {
                fst = sum_num_matrix[i,j] / sum_den_matrix[i,j];
                catn(" Hudson Fst  = " + fst);
            } else {
                catn(" Hudson Fst = NA (denominador = 0)");
            }
            catn("");
        }
   }
catn("\nFINISH");     
}//finish late


